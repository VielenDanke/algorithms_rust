use itertools::Itertools;
use std::iter::once;

pub struct Solution;

impl Solution {
    /// Вычисляет максимально возможную длину `k` такую, что массив можно разделить
    /// на две непересекающиеся части, каждая из которых содержит возрастающую
    /// подпоследовательность (ВП) длины не менее `k`.
    ///
    /// Эта функция пытается решить задачу за один проход, но, похоже,
    /// её логика основана на **ошибочном предположении** о том, как должны
    /// сочетаться возрастающие подмассивы, и она **не решает** исходную задачу
    /// корректно. Исходная задача требует найти две *непересекающиеся*
    /// возрастающие подпоследовательности. Эта реализация, скорее всего,
    /// ищет что-то другое (возможно, связанные с двумя смежными возрастающими
    /// *подмассивами*).
    ///
    /// В оригинальной задаче требуется проверить две непересекающиеся ВП,
    /// что обычно предполагает использование **бинарного поиска** по ответу `k`
    /// в сочетании с алгоритмом, подобным поиску самой длинной возрастающей
    /// подпоследовательности (L**I**S) или динамическому программированию
    /// для проверки выполнимости.
    ///
    /// # Параметры
    /// * `nums`: Входной вектор целых чисел.
    ///
    /// # Возвращает
    /// Максимально возможная длина `k` (но, вероятно, неверно для оригинальной задачи).
    pub fn max_increasing_subarrays_faster(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        // Краевой случай: если массив пуст или состоит из одного элемента, ответ 0.
        if n < 2 {
            return 0;
        }

        // `cnt`: Длина текущего возрастающего **подмассива** (смежного).
        let mut cnt = 1;
        // `precnt`: Длина предыдущего завершенного возрастающего **подмассива**.
        let mut precnt = 0;
        // `ans`: Текущий максимальный ответ.
        let mut ans = 0;

        // Итерация, начиная со второго элемента.
        for i in 1..n {
            // Проверка, продолжает ли элемент `nums[i]` текущий возрастающий подмассив.
            if nums[i] > nums[i - 1] {
                cnt += 1;
            } else {
                // Если возрастающий подмассив прерывается, сохраняем его длину как "предыдущую".
                precnt = cnt;
                // Начинаем новый возрастающий подмассив с длиной 1.
                cnt = 1;
            }

            // Логика, которая, по-видимому, пытается найти максимальную длину `k`
            // на основе двух *смежных* возрастающих *подмассивов* (`precnt` и `cnt`).
            // Мы берем минимальную длину из двух смежных подмассивов.
            ans = ans.max(precnt.min(cnt));

            // Логика, которая, по-видимому, пытается найти максимальную длину `k`
            // на основе одного возрастающего *подмассива* (`cnt`), деленного на 2.
            // (Поскольку две ВП длины `k` могут быть сформированы из подмассива длины `2k-1` или больше).
            ans = ans.max(cnt / 2);
        }

        // Возвращаем найденный максимум.
        ans
    }

    /// Вычисляет максимально возможную длину `k` такую, что массив можно разделить
    /// на две непересекающиеся части, каждая из которых содержит возрастающую
    /// подпоследовательность (ВП) длины не менее `k`.
    ///
    /// Эта функция использует подход **бинарного поиска по ответу** `k`.
    /// Она перебирает возможные длины `k` (`window`) в убывающем порядке.
    ///
    /// Для каждого `k` она проверяет, можно ли найти две непересекающиеся
    /// **возрастающие подпоследовательности** длины не менее `k`.
    /// Однако, **реализация проверки** здесь, похоже, также имеет **ошибку**
    /// и ищет две непересекающиеся **возрастающие *подмассивы* (смежные)**
    /// длины `k`, а не подпоследовательности.
    ///
    /// # Параметры
    /// * `nums`: Входной вектор целых чисел.
    ///
    /// # Возвращает
    /// Максимально возможная длина `k` (но, вероятно, неверно для оригинальной задачи).
    pub fn max_increasing_subarrays(nums: Vec<i32>) -> i32 {
        // Начинаем бинарный поиск (или линейный поиск с конца) с максимальной
        // возможной длины, которая составляет половину размера массива.
        let mut window = nums.len() / 2;

        // Перебираем длины `k` (`window`) в убывающем порядке.
        while window > 0 {
            // `win1`: Длина текущего возрастающего **подмассива** для первой части.
            let mut win1 = 0;
            // `win2`: Длина текущего возрастающего **подмассива** для второй части (со сдвигом `window`).
            let mut win2 = 0;

            // `it1`: Итератор, который дает пары соседних элементов `(предыдущий, текущий)`
            // для отслеживания длины возрастающего **подмассива**.
            // `once(&0).chain(&nums)`: Добавляем фиктивный элемент `0` в начало, чтобы
            // первая пара была `(0, nums[0])`.
            // `.copied().tuple_windows()`: Создает пары `(nums[i-1], nums[i])`.
            let it1 = once(&0).chain(&nums).copied().tuple_windows();

            // `it2`: Итератор, смещенный относительно `it1` на `window`.
            // Это сделано для того, чтобы проверять вторую возрастающую последовательность,
            // которая начинается на `window` позиций позже первой.
            let it2 = it1.clone().skip(window as usize);

            // Итерируемся по элементам `it1` и `it2` одновременно.
            if it1.zip(it2).any(move |((pn1, n1), (pn2, n2))| {
                // Логика отслеживания длины **возрастающего *подмассива*** для первой части (`win1`).
                // pn1 - предыдущий элемент, n1 - текущий элемент.
                win1 = if pn1 < n1 { win1 + 1 } else { 1 };
                // Логика отслеживания длины **возрастающего *подмассива*** для второй части (`win2`).
                // pn2 - предыдущий элемент, n2 - текущий элемент.
                win2 = if pn2 < n2 { win2 + 1 } else { 1 };

                // Проверяем, достигли ли обе части возрастающего **подмассива** длины `window`.
                // **Внимание:** Эта проверка ищет *смежные* возрастающие подмассивы,
                // а не *непересекающиеся* возрастающие *подпоследовательности*.
                win1 >= window && win2 >= window
            }) {
                // Если две непересекающиеся части найдены, то `window` - это ответ.
                return window as i32;
            }
            // Уменьшаем размер окна и пробуем меньшую длину `k`.
            window -= 1;
        }
        // Если ничего не найдено, максимальная длина `k` равна 0.
        window as i32 // window будет 0.
    }
}
pub struct Solution;

impl Solution {
    /// Вычисляет минимальное общее время, необходимое для выполнения N операций.
    /// Каждая операция имеет базовую "стоимость" (skill[i]) и подвергается
    /// влиянию ряда "множителей" (mana).
    pub fn min_time(skill: Vec<i32>, mana: Vec<i32>) -> i64 {
        let n = skill.len();
        // Создаем вектор 'times' длины N, инициализированный нулями.
        // times[i] будет хранить минимальное время завершения операции i
        // с учетом всех ранее обработанных множителей 'mana'.
        let mut times = vec![0i64; n];

        // --- Внешний цикл: Итерация по каждому множителю 'mana' ---
        // Каждый множитель 'mj' представляет собой новый "раунд" или "условие",
        // которое влияет на время выполнения всех N операций.
        for &mj in &mana {
            // Переменная для отслеживания времени завершения последней выполненной операции
            // в *текущем* раунде 'mj'.
            let mut cur_time: i64 = 0;

            // --- Прямой проход: Вычисление суммарного времени (0 -> n-1) ---
            for i in 0..n {
                // 1. Время начала: Определяем, когда может начаться операция 'i'.
                //    Она должна начаться не раньше:
                //    a) 'cur_time': Время завершения предыдущей операции (i-1) в этом раунде 'mj'.
                //    b) 'times[i]': Время завершения операции 'i' из всех предыдущих раундов 'mana'.
                //    Таким образом, мы берем максимум, чтобы учесть зависимости.
                let start_time = std::cmp::max(cur_time, times[i]);

                // 2. Время выполнения: Вычисляем время, которое займет операция 'i'
                //    в этом раунде: skill[i] * mj.
                let execution_time = skill[i] as i64 * mj as i64;

                // 3. Время завершения: Обновляем 'cur_time' как время завершения
                //    операции 'i' в этом раунде.
                cur_time = start_time + execution_time;
            }

            // Время завершения последней операции (n-1) в текущем раунде 'mj'
            // является самым свежим итоговым временем.
            times[n - 1] = cur_time;

            // --- Обратный проход: Восстановление промежуточных результатов ((n-1) -> 0) ---
            // Мы "откатываем" общее время, чтобы обновить 'times[i]' для всех i < n-1.
            // Теперь times[i] будет хранить минимальное время завершения операции 'i',
            // необходимое для достижения нового 'times[n-1]'.
            for i in (0..n - 1).rev() {
                // Вычитаем время выполнения операции (i+1) из времени её завершения.
                // Это дает нам время, к которому должна быть завершена операция 'i' (т.е.,
                // время начала операции i+1).
                let prev_execution_time = skill[i + 1] as i64 * mj as i64;
                times[i] = times[i + 1] - prev_execution_time;
            }
        }

        // --- Результат ---
        // После обработки всех множителей 'mana', times[n - 1] содержит
        // минимальное общее время завершения последней операции.
        times[n - 1]
    }
}